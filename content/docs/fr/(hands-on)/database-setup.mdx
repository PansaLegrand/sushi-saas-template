---
title: Mise en place de la base de donnÃ©es
icon: "Database"
description: PrÃ©parer Postgres et Drizzle ORM â€” lâ€™Ã©pine dorsale pour lâ€™auth, la facturation, le stockage, les tÃ¢ches et les tables mÃ©tier.
keywords:
  - Postgres
  - Drizzle ORM
  - migrations
  - Better Auth
  - schÃ©ma
  - Next.js
  - base de donnÃ©es
tags: [base de donnÃ©es, Drizzle, Postgres]
author: "Pansa Legrand"
publishedAt: "2025-09-29T00:00:00.000Z"
updatedAt: "2025-09-29T00:00:00.000Z"
canonical: "https://www.sushi-templates.com/fr/blogs/database-setup"
---

La base de donnÃ©es est le centre dâ€™un SaaS moderne. Toutes les fonctionnalitÃ©s rÃ©elles â€” authentification, facturation, crÃ©dits, stockage, suivi dâ€™usage, modules de dÃ©monstration â€” passent par la base. On plaisante parfois en disant que nous sommes des Â«Â ingÃ©nieurs CRUDÂ Â»Â : crÃ©er, lire, mettre Ã  jour, supprimer, câ€™est le cÅ“ur du quotidien. Plus le schÃ©ma grandit, plus il faut traiter la base comme fondation pour garder une app prÃ©visible.

Ce guide met la base au premier planÂ : cartographier le schÃ©ma vers les fonctionnalitÃ©s, expliquer le CRUD typÃ© avec Drizzle, puis connecter, migrer et valider.

## Pourquoi la base passe en premier

- SystÃ¨me de rÃ©fÃ©renceÂ : auth, facturation, fichiers et tÃ¢ches sont persistÃ©s ici et joints cÃ´tÃ© services/APIs.
- SchÃ©ma â†’ Types â†’ UIÂ : les modÃ¨les Drizzle dans `src/db/schema.ts` fournissent des types sÃ»rs partagÃ©s dans les modÃ¨les et routes.
- Le CRUD comme surface produitÂ : la plupart des Ã©crans sont des listes/dÃ©tails en lecture/Ã©criture. Un bon modÃ¨le de tables accÃ©lÃ¨re lâ€™UI.

### Domaines clÃ©s (tables â†’ fonctionnalitÃ©s)

- AuthÂ : `users`, `sessions`, `accounts`, `verifications` pour Better Auth.
- Facturation & crÃ©ditsÂ : `orders`, `credits` suivent achats et Ã©critures de crÃ©dit.
- StockageÂ : `files` contient les mÃ©tadonnÃ©es S3/R2 et le cycle de vie (uploading â†’ active â†’ deleted).
- Usage & tÃ¢ches (IA)Â : `tasks` enregistre queued/running/completed, avec `credits_trans_no` vers le grand livre.
- ContenuÂ : `posts` pour des instantanÃ©s de contenu.
- Croissance & feedbackÂ : `affiliates`, `feedbacks`.
- DÃ©moÂ : `reservation_services`, `reservations` illustrent planification/paiement dâ€™acompte.

### Patrons centrÃ©s CRUD dans le code

- Les modÃ¨les vivent dans `src/models/*` et exposent des helpers typÃ©sÂ :
  - `src/models/file.ts`Â : `insertFile`, `findFileByUuid`, `updateFileByUuid`, `listFilesByUser`, `softDeleteFile`.
  - `src/models/task.ts`Â : `insertTask`, `findTaskByUuid`, `getTasksByUserUuid`, `updateTaskStatus`.
- Les services et routes API appellent ces helpersÂ ; centralisez lâ€™accÃ¨s DB.
- Pour ajouter une fonctionnalitÃ©Â : tables dans `src/db/schema.ts` â†’ `pnpm drizzle-kit generate` â†’ `pnpm drizzle-kit migrate` â†’ `src/models/<domaine>.ts` â†’ usages dans `src/services/*` et les routes.

## 1. Quâ€™est-ce que Drizzle ORM ?

Nous utilisons **[Drizzle ORM](https://orm.drizzle.team/)** comme couche typÃ©e
entre TypeScript et Postgres. Le schÃ©ma dans `src/db/schema.ts` fait foi. Depuis
ce fichier nous pouvons :

- GÃ©nÃ©rer des migrations SQL avec `drizzle-kit`
- ExÃ©cuter ces migrations sur Postgres
- Partager des types dans tout le projet (ex. `users.$inferSelect`)

Inutile dâ€™Ã©crire du SQL Ã  la main : modifiez le schÃ©ma et laissez Drizzle gÃ©rer
les migrations.

## 2. Choisir votre scÃ©nario base de donnÃ©es

Adaptez la configuration Ã  votre contexte et mettez `.env` Ã  jour.

| ScÃ©nario | Recommandation |
| --- | --- |
| **DÃ©veloppement local uniquement** | Lancer Postgres via Docker (ex. `docker run ... postgres:16`) et pointer `DATABASE_URL` sur `postgres://postgres:postgres@localhost:5432/postgres`. |
| **Postgres managÃ© (Neon, Supabase, Railway, Renderâ€¦)** | Utiliser la chaÃ®ne de connexion fournie et autoriser lâ€™adresse IP depuis laquelle vous exÃ©cutez les migrations. |
| **Une base diffÃ©rente par environnement** | Conserver `.env` pour le local et stocker les secrets de production directement dans votre hÃ©bergeur. |
| **Base existante avec dâ€™autres tables** | Drizzle ne touchera quâ€™aux tables dÃ©finies dans `src/db/schema.ts`. VÃ©rifiez quâ€™il nâ€™y ait pas de collision de noms ou utilisez un schÃ©ma dÃ©diÃ©. |

> Astuce : Drizzle ne crÃ©e pas la base de donnÃ©es. CrÃ©ez-la au prÃ©alable (UI du
> fournisseur ou `psql`).

## 3. Configurer les variables dâ€™environnement

DÃ©finissez la chaÃ®ne Postgres et les secrets Better Auth. Le projet lit `.env`,
`.env.local` et `.env.development`.

```bash  title=".env"
DATABASE_URL="postgresql://user:password@host:5432/db?sslmode=require"
BETTER_AUTH_SECRET="$(openssl rand -base64 32)"
BETTER_AUTH_URL="http://localhost:3000"
```

RedÃ©marrez `pnpm dev` aprÃ¨s chaque modification pour recharger ces valeurs.

## 4. Comprendre les fichiers de schÃ©ma

- `src/db/schema.ts` â€“ modÃ¨les Drizzle pour **Better Auth** (`users`, `sessions`,
  `accounts`, `verifications`) et les tables mÃ©tierÂ : `orders`, `credits`, `files`,
  `tasks`, `posts`, `affiliates`, `feedbacks`, `reservation_services`,
  `reservations`.
- `src/db/config.ts` â€“ configuration drizzle-kit (chemin du schÃ©ma + URL
  Postgres).
- `src/lib/auth.ts` â€“ correspondance des champs Better Auth avec les colonnes
  Drizzle. Ã€ adapter si vous renommez des colonnes dans `users`.

Ajoutez vos colonnes/tables dans `schema.ts` puis ajustez `auth.ts` si nÃ©cessaire. Pensez Ã  ajouter des index dans `schema.ts` (`uniqueIndex`/`index`) pour garder de bonnes perfs en lecture quand les donnÃ©es grossissent.

## 5. GÃ©nÃ©rer une migration aprÃ¨s chaque modification

DÃ¨s que `schema.ts` change :

```bash
pnpm drizzle-kit generate --config src/db/config.ts
```

Exemple de sortie :

```
Reading config file 'src/db/config.ts'
...
[âœ“] Your SQL migration file âœ src/db/migrations/0002_add_user_flag.sql ğŸš€
```

Deux fichiers sont crÃ©Ã©s :

- `src/db/migrations/<timestamp>_*.sql`
- `src/db/migrations/meta/_journal.json`

Commitez-les.

## 6. Appliquer les migrations

Poussez le SQL vers Postgres :

```bash
pnpm drizzle-kit migrate --config src/db/config.ts
```

Sortie attendue :

```
Applying migrations from src/db/migrations
Migration 0002_add_user_flag.sql executed in 380 ms
All migrations applied!
```

Si la commande Ã©choue, vÃ©rifiez `DATABASE_URL`, vos droits rÃ©seau ou que votre
instance Postgres tourne toujours.

## 7. VÃ©rifier le rÃ©sultat

Inspectez les tables avec lâ€™outil de votre choix. Exemple `psql` :

```sql
\dt
SELECT * FROM sessions LIMIT 1;
SELECT email_verified FROM users LIMIT 1;
```

Vous devriez voir les tables Better Auth et les tables cÅ“ur de lâ€™app. Pour une vÃ©rification CRUD rapide, insÃ©rez puis lisez une ligne via un helper modÃ¨le (par ex., crÃ©ez une ligne minimale dans `files` via `POST /api/storage/uploads`, puis `SELECT * FROM files LIMIT 1;`).

## 8. Tester le flux dâ€™authentification

AprÃ¨s les migrations, redÃ©marrez `pnpm dev`, ouvrez `/fr/signup` (ou votre
locale) et crÃ©ez un utilisateur. Vous serez redirigÃ© vers lâ€™accueil et les
lignes `users` / `sessions` seront crÃ©Ã©es.

## 9. DÃ©pannage

- **Error: model "userss" not found** â€“ Assurez-vous que `src/lib/auth.ts`
  utilise bien `users`; supprimez `usePlural` si besoin.
- **Colonne manquante** â€“ Vous avez modifiÃ© `schema.ts` mais oubliÃ© `generate`
  et `migrate`.
- **Impossible de se connecter** â€“ VÃ©rifiez lâ€™existence de la base, le couple
  login/mot de passe et les rÃ¨gles rÃ©seau.
- **Repartir de zÃ©ro** â€“ Supprimez les tables Ã  la main ou rejouez le SQL
  inverse, puis regÃ©nÃ©rez.

Respectez toujours la boucle : modifier â†’ gÃ©nÃ©rer â†’ migrer â†’ vÃ©rifier. Ainsi, vos
pages dâ€™authentification resteront stables.
